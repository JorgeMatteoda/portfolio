# -*- coding: utf-8 -*-
"""stock_valorization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VxfdUEUxvgzALyo_WdLeXSOyv2BCz2x3

# Retrieving EPS_ttm
"""

import pandas as pd

# Datos iniciales (ajustando los días inválidos)
data = {
    "trimestre": [
        "31/03/2021","30/06/2021","30/09/2021","31/12/2021",
        "31/03/2022","30/06/2022","30/09/2022","31/12/2022",
        "31/03/2023","30/06/2023","30/09/2023","31/12/2023",
        "31/03/2024","30/06/2024","30/09/2024","31/12/2024",
        "31/03/2025","30/06/2025"
    ],
    "EPS_usd": [
        0.01368,0.009431,0.018878,0.01334,
        0.014197,0.013211,0.017063,0.007419,
        0.007398,-0.001385,0.015604,0.01144,
        0.002053,0.002308,0.013943,0.014031,
        0.003388,0.00589125
    ],
    "EPS_clp": [
        10.01376,6.931785,15.177912,11.339,
        11.173039,12.15412,16.482858,6.38034,
        5.837022,-1.112155,14.152828,10.1244,
        2.016046,2.194908,12.492928,13.918752,
        3.205048,5.537775
    ]
}

# Convertir a DataFrame
df = pd.DataFrame(data)
df["trimestre"] = pd.to_datetime(df["trimestre"], dayfirst=True)

# Expandir trimestrales a mensuales
monthly_eps = []

for i, row in df.iterrows():
    q_date = row["trimestre"]
    eps_q = row["EPS_clp"]
    eps_m = eps_q / 3  # repartir el EPS trimestral en 3 meses

    # generar los 3 meses de ese trimestre
    for j in range(3):
        month_date = (q_date - pd.DateOffset(months=2)) + pd.DateOffset(months=j)
        monthly_eps.append({"fecha": month_date, "EPS_mensual": eps_m})

monthly_df = pd.DataFrame(monthly_eps).sort_values("fecha").reset_index(drop=True)

# Calcular EPS TTM (últimos 12 meses móviles)
monthly_df["EPS_TTM"] = monthly_df["EPS_mensual"].rolling(window=12, min_periods=12).sum()

print(monthly_df.head(20))
#print(monthly_df.tail(20))

"""# Retrieving price stock data from yahoo finance"""

import yfinance as yf
import pandas as pd
from datetime import date

# Define the ticker symbol
ticker = "ENELAM.SN"

# Define the start date
start_date = "2021-01-01"

# Get today's date for the end date
end_date = date.today().strftime("%Y-%m-%d")

# Download the historical stock data
stock_data = yf.download(ticker, start=start_date, end=end_date)

print(stock_data)
print(stock_data.info())

# --- Suponiendo que ya tienes monthly_df con 'fecha' ---
# Convertimos 'fecha' en datetime (por si acaso) y al fin de mes
monthly_df["fecha"] = pd.to_datetime(monthly_df["fecha"]) + pd.offsets.MonthEnd(0)

# Lo ponemos como índice
monthly_df.set_index("fecha", inplace=True)

# --- Descargar precios de ENELAM.SN y resample a fin de mes ---
ticker = "ENELAM.SN"
start_date = monthly_df.index.min().strftime("%Y-%m-%d")
end_date = monthly_df.index.max().strftime("%Y-%m-%d")

stock_data = yf.download(ticker, start=start_date, end=end_date)

# Tomar solo columna Close y fin de mes
# monthly_prices = stock_data[["Close"]].resample("ME").last()
monthly_prices = stock_data[["Close"]].resample("ME").mean()
monthly_prices = monthly_prices.rename(columns={"Close": "Precio"})

# --- Concatenar por índice ---
df_concat = pd.concat([monthly_prices, monthly_df], axis=1)

# --- Mostrar resultado ---
print(df_concat.tail(15))

# Eliminar filas con NaN en cualquier columna
df_concat = df_concat.dropna()

print(df_concat.tail(10))

# Aplanar columnas si tienen MultiIndex
df_concat.columns = [col[0] if isinstance(col, tuple) else col for col in df_concat.columns]

if "Close" in df_concat.columns:
    df_concat = df_concat.rename(columns={"Close": "Precio"})

import numpy as np

df_concat["P_E"] = np.where(
    df_concat["EPS_TTM"] > 0,
    df_concat["Precio"] / df_concat["EPS_TTM"],
    np.nan
)

print(df_concat[["Precio", "EPS_TTM", "P_E"]].tail(10))

import matplotlib.pyplot as plt

plt.figure(figsize=(12,6))

# Eje principal para Precio
fig, ax1 = plt.subplots(figsize=(12,6))
ax1.plot(df_concat.index, df_concat["Precio"], color="blue", label="Precio")
ax1.set_xlabel("Fecha")
ax1.set_ylabel("Precio", color="blue")
ax1.tick_params(axis="y", labelcolor="blue")

# Eje secundario para P/E
ax2 = ax1.twinx()
ax2.plot(df_concat.index, df_concat["P_E"], color="red", label="P/E")
ax2.set_ylabel("P/E", color="red")
ax2.tick_params(axis="y", labelcolor="red")

# Título
plt.title("Precio y P/E de ENELAM")

# Mostrar
plt.show()

import matplotlib.pyplot as plt

# Calcular mediana de P/E (ignorando NaN)
mediana_pe = df_concat["P_E"].median()

fig, ax1 = plt.subplots(figsize=(12,6))

# Eje principal: Precio
ax1.plot(df_concat.index, df_concat["Precio"], color="blue", label="Precio")
ax1.set_xlabel("Fecha")
ax1.set_ylabel("Precio", color="blue")
ax1.tick_params(axis="y", labelcolor="blue")

# Eje secundario: P/E
ax2 = ax1.twinx()
ax2.plot(df_concat.index, df_concat["P_E"], color="red", label="P/E")
ax2.axhline(mediana_pe, color="green", linestyle="--", label=f"Mediana P/E = {mediana_pe:.2f}")
ax2.set_ylabel("P/E", color="red")
ax2.tick_params(axis="y", labelcolor="red")

# Título y leyenda
plt.title("Precio y P/E de ENELAM con Mediana de P/E")
fig.legend(loc="upper left", bbox_to_anchor=(0.1,0.9))

plt.show()

import matplotlib.pyplot as plt

# Calcular mediana de P/E
mediana_pe = df_concat["P_E"].median()

# Crear columna de precio justificado
df_concat["Precio_Justificado"] = df_concat["EPS_TTM"] * mediana_pe

# Gráfico comparativo
plt.figure(figsize=(12,6))
plt.plot(df_concat.index, df_concat["Precio"], label="Precio Real", color="blue")
plt.plot(df_concat.index, df_concat["Precio_Justificado"], label=f"Precio Justificado (EPS_TTM * {mediana_pe:.2f})", color="orange", linestyle="--")

plt.title("Precio Real vs Precio Justificado por Mediana P/E")
plt.xlabel("Fecha")
plt.ylabel("Precio")
plt.legend()
plt.grid(True)
plt.show()

"""**Reasoning**:
Find the last non-null value in the 'EPS_TTM' column to use for extending the 'Precio Justificado' line.


"""

# Select the 'EPS_TTM' column, remove NaN values, and get the last value
last_eps_ttm = df_concat["EPS_TTM"].dropna().iloc[-1]

print(f"Last available non-null EPS_TTM value: {last_eps_ttm:.2f}")

import pandas as pd

# 1. Create a list of datetime objects for the end of July, August, and September 2025.
future_dates = pd.to_datetime(["2025-07-31", "2025-08-31", "2025-09-30"])

# 2. Create a list containing the calculated avg_future_price repeated for each of the three future months.
future_prices = [df_concat.iloc[0]] * len(future_dates)

# 3. Create a list containing the last_eps_ttm value multiplied by the median P/E (2.86) for each of the three future months.
future_justified_prices = [last_eps_ttm * mediana_pe] * len(future_dates)

# 4. Create a new DataFrame for the future data.
future_df = pd.DataFrame({
    "Precio": future_prices,
    "Precio_Justificado": future_justified_prices
}, index=future_dates)

print(future_df)
future_df

"""## Combine data

### Subtask:
Combine the original `df_concat` data with the newly created future data points.

**Reasoning**:
Concatenate the historical and future dataframes and display the tail to confirm the result.
"""

# Concatenate the original df_concat and future_df DataFrames
df_combined = pd.concat([df_concat, future_df])

# Display the last few rows of the combined DataFrame
print(df_combined.tail())

